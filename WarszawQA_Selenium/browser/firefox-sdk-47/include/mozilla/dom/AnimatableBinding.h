/* THIS FILE IS AUTOGENERATED FROM Animatable.webidl BY Codegen.py - DO NOT EDIT */

#ifndef mozilla_dom_AnimatableBinding_h
#define mozilla_dom_AnimatableBinding_h

#include "AnimationEffectReadOnlyBinding.h"
#include "KeyframeBinding.h"
#include "KeyframeEffectBinding.h"
#include "js/RootingAPI.h"
#include "jspubtd.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/UnionMember.h"
#include "mozilla/dom/UnionTypes.h"

namespace mozilla {
namespace dom {

struct KeyframeAnimationOptionsAtoms;
struct NativePropertyHooks;
class OwningUnrestrictedDoubleOrString;
class ProtoAndIfaceCache;
class UnrestrictedDoubleOrString;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

struct KeyframeAnimationOptions : public KeyframeEffectOptions
{
  nsString mId;

  KeyframeAnimationOptions();

  explicit inline KeyframeAnimationOptions(const FastDictionaryInitializer& )
    : KeyframeEffectOptions(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline KeyframeAnimationOptions(const KeyframeAnimationOptions& aOther)
  {
    *this = aOther;
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(const nsAString& aJSON);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);

  void
  operator=(const KeyframeAnimationOptions& aOther);

private:
  static bool
  InitIds(JSContext* cx, KeyframeAnimationOptionsAtoms* atomsCache);
};

namespace binding_detail {
struct FastKeyframeAnimationOptions : public KeyframeAnimationOptions
{
  inline FastKeyframeAnimationOptions()
    : KeyframeAnimationOptions(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


class UnrestrictedDoubleOrKeyframeAnimationOptions
{
  friend class UnrestrictedDoubleOrKeyframeAnimationOptionsArgument;
  enum Type
  {
    eUninitialized,
    eUnrestrictedDouble,
    eKeyframeAnimationOptions
  };

  union Value
  {
    UnionMember<double > mUnrestrictedDouble;
    UnionMember<binding_detail::FastKeyframeAnimationOptions > mKeyframeAnimationOptions;

  };

  Type mType;
  Value mValue;

  UnrestrictedDoubleOrKeyframeAnimationOptions(const UnrestrictedDoubleOrKeyframeAnimationOptions&) = delete;
  void operator=(const UnrestrictedDoubleOrKeyframeAnimationOptions) = delete;
public:
  explicit inline UnrestrictedDoubleOrKeyframeAnimationOptions()
    : mType(eUninitialized)
  {
  }

  inline ~UnrestrictedDoubleOrKeyframeAnimationOptions()
  {
    Uninit();
  }

  inline double&
  RawSetAsUnrestrictedDouble()
  {
    if (mType == eUnrestrictedDouble) {
      return mValue.mUnrestrictedDouble.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eUnrestrictedDouble;
    return mValue.mUnrestrictedDouble.SetValue();
  }

  inline double&
  SetAsUnrestrictedDouble()
  {
    if (mType == eUnrestrictedDouble) {
      return mValue.mUnrestrictedDouble.Value();
    }
    Uninit();
    mType = eUnrestrictedDouble;
    return mValue.mUnrestrictedDouble.SetValue();
  }

  inline bool
  IsUnrestrictedDouble() const
  {
    return mType == eUnrestrictedDouble;
  }

  inline double&
  GetAsUnrestrictedDouble()
  {
    MOZ_ASSERT(IsUnrestrictedDouble(), "Wrong type!");
    return mValue.mUnrestrictedDouble.Value();
  }

  inline double
  GetAsUnrestrictedDouble() const
  {
    MOZ_ASSERT(IsUnrestrictedDouble(), "Wrong type!");
    return mValue.mUnrestrictedDouble.Value();
  }

  inline binding_detail::FastKeyframeAnimationOptions&
  RawSetAsKeyframeAnimationOptions()
  {
    if (mType == eKeyframeAnimationOptions) {
      return mValue.mKeyframeAnimationOptions.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eKeyframeAnimationOptions;
    return mValue.mKeyframeAnimationOptions.SetValue();
  }

  inline binding_detail::FastKeyframeAnimationOptions&
  SetAsKeyframeAnimationOptions()
  {
    if (mType == eKeyframeAnimationOptions) {
      return mValue.mKeyframeAnimationOptions.Value();
    }
    Uninit();
    mType = eKeyframeAnimationOptions;
    return mValue.mKeyframeAnimationOptions.SetValue();
  }

  inline bool
  IsKeyframeAnimationOptions() const
  {
    return mType == eKeyframeAnimationOptions;
  }

  inline binding_detail::FastKeyframeAnimationOptions&
  GetAsKeyframeAnimationOptions()
  {
    MOZ_ASSERT(IsKeyframeAnimationOptions(), "Wrong type!");
    return mValue.mKeyframeAnimationOptions.Value();
  }

  inline const KeyframeAnimationOptions&
  GetAsKeyframeAnimationOptions() const
  {
    MOZ_ASSERT(IsKeyframeAnimationOptions(), "Wrong type!");
    return mValue.mKeyframeAnimationOptions.Value();
  }

  inline void
  Uninit()
  {
    switch (mType) {
      case eUninitialized: {
        break;
      }
      case eUnrestrictedDouble: {
        DestroyUnrestrictedDouble();
        break;
      }
      case eKeyframeAnimationOptions: {
        DestroyKeyframeAnimationOptions();
        break;
      }
    }
  }

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

private:
  inline void
  DestroyUnrestrictedDouble()
  {
    MOZ_ASSERT(IsUnrestrictedDouble(), "Wrong type!");
    mValue.mUnrestrictedDouble.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyKeyframeAnimationOptions()
  {
    MOZ_ASSERT(IsKeyframeAnimationOptions(), "Wrong type!");
    mValue.mKeyframeAnimationOptions.Destroy();
    mType = eUninitialized;
  }
};


class OwningUnrestrictedDoubleOrKeyframeAnimationOptions : public AllOwningUnionBase
{
  friend void ImplCycleCollectionUnlink(OwningUnrestrictedDoubleOrKeyframeAnimationOptions& aUnion);
  enum Type
  {
    eUninitialized,
    eUnrestrictedDouble,
    eKeyframeAnimationOptions
  };

  union Value
  {
    UnionMember<double > mUnrestrictedDouble;
    UnionMember<KeyframeAnimationOptions > mKeyframeAnimationOptions;

  };

  Type mType;
  Value mValue;

public:
  explicit inline OwningUnrestrictedDoubleOrKeyframeAnimationOptions()
    : mType(eUninitialized)
  {
  }

  explicit inline OwningUnrestrictedDoubleOrKeyframeAnimationOptions(const OwningUnrestrictedDoubleOrKeyframeAnimationOptions& aOther)
    : mType(eUninitialized)
  {
    *this = aOther;
  }

  inline ~OwningUnrestrictedDoubleOrKeyframeAnimationOptions()
  {
    Uninit();
  }

  double&
  RawSetAsUnrestrictedDouble();

  double&
  SetAsUnrestrictedDouble();

  bool
  TrySetToUnrestrictedDouble(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsUnrestrictedDouble() const
  {
    return mType == eUnrestrictedDouble;
  }

  inline double&
  GetAsUnrestrictedDouble()
  {
    MOZ_ASSERT(IsUnrestrictedDouble(), "Wrong type!");
    return mValue.mUnrestrictedDouble.Value();
  }

  inline double const &
  GetAsUnrestrictedDouble() const
  {
    MOZ_ASSERT(IsUnrestrictedDouble(), "Wrong type!");
    return mValue.mUnrestrictedDouble.Value();
  }

  KeyframeAnimationOptions&
  RawSetAsKeyframeAnimationOptions();

  KeyframeAnimationOptions&
  SetAsKeyframeAnimationOptions();

  bool
  TrySetToKeyframeAnimationOptions(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsKeyframeAnimationOptions() const
  {
    return mType == eKeyframeAnimationOptions;
  }

  inline KeyframeAnimationOptions&
  GetAsKeyframeAnimationOptions()
  {
    MOZ_ASSERT(IsKeyframeAnimationOptions(), "Wrong type!");
    return mValue.mKeyframeAnimationOptions.Value();
  }

  inline KeyframeAnimationOptions const &
  GetAsKeyframeAnimationOptions() const
  {
    MOZ_ASSERT(IsKeyframeAnimationOptions(), "Wrong type!");
    return mValue.mKeyframeAnimationOptions.Value();
  }

  void
  Uninit();

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceUnion(JSTracer* trc);

  void
  operator=(const OwningUnrestrictedDoubleOrKeyframeAnimationOptions& aOther);

private:
  void
  DestroyUnrestrictedDouble();

  void
  DestroyKeyframeAnimationOptions();
};


} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_AnimatableBinding_h
